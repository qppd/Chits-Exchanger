    elif detection_state == "CONFIRMED":
        # Detection confirmed, now release chit
        t_detect_stop = time.perf_counter()
        detection_time = t_detect_stop - t_detect_start
        
        print(f"\n{'='*60}")
        print(f"üéâ DETECTION COMPLETE")
        print(f"{'='*60}")
        print(f"   Detected Value: ‚Ç±{confirmed_chit_value}")
        print(f"   Confidence: {confirmed_confidence:.2%}")
        print(f"   Detection Time: {detection_time:.3f}s")
        print(f"{'='*60}")
        
        # Show confirmed detection on frame
        display_frame = frame.copy()
        display_frame = cv2.resize(display_frame, (320, 240))
        cv2.putText(display_frame, f'CONFIRMED: P{confirmed_chit_value}', (10, 30), 
                   cv2.FONT_HERSHEY_SIMPLEX, 0.9, (0, 255, 0), 2)
        cv2.putText(display_frame, f'Conf: {confirmed_confidence:.1%}', (10, 60), 
                   cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)
        cv2.putText(display_frame, 'Releasing chit...', (10, 90), 
                   cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 255, 0), 2)
        
        if use_gui:
            cv2.imshow('Chit Detection - Real-time', display_frame)
            cv2.waitKey(1)
        
        # Update LCD
        lcd.display_lines(
            "DETECTED!",
            f"Value: P{confirmed_chit_value}",
            f"Conf: {int(confirmed_confidence*100)}%",
            "Releasing chit..."
        )
        
        # Send detection result to ESP32
        send_to_esp32(f"CHIT_DETECTED:{confirmed_chit_value}")
        
        # Release the chit (non-blocking)
        print(f"üîì Releasing chit via servo...")
        release_chit()
        
        # Move to RELEASING state
        detection_state = "RELEASING"
    
    elif detection_state == "RELEASING":
        # Wait for servo release to complete before dispensing
        display_frame = frame.copy()
        display_frame = cv2.resize(display_frame, (320, 240))
        cv2.putText(display_frame, f'Releasing: P{confirmed_chit_value}', (10, 30), 
                   cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 255, 255), 2)
        cv2.putText(display_frame, 'Please wait...', (10, 60), 
                   cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 255), 2)
        
        if use_gui:
            cv2.imshow('Chit Detection - Real-time', display_frame)
            cv2.waitKey(1)
        
        # Check if servo release is complete
        if not servo_release_active:
            print(f"‚úÖ Chit ‚Ç±{confirmed_chit_value} released successfully")
            
            # Auto-dispense: Send command to ESP32 to dispense detected amount
            print(f"\n{'='*60}")
            print(f"ü™ô AUTO-DISPENSING TRIGGERED")
            print(f"{'='*60}")
            print(f"   Sending to ESP32: AUTO_DISPENSE:{confirmed_chit_value}")
            print(f"   Expected dispensing:")
            
            # Show expected coin breakdown
            if confirmed_chit_value == 5:
                print(f"     - 1 x 5 PHP coin (Hopper 1)")
            elif confirmed_chit_value == 10:
                print(f"     - 1 x 10 PHP coin (Hopper 2)")
            elif confirmed_chit_value == 20:
                print(f"     - 1 x 20 PHP coin (Hopper 3)")
            elif confirmed_chit_value == 50:
                print(f"     - 2 x 20 PHP coins (Hopper 3)")
                print(f"     - 1 x 10 PHP coin (Hopper 2)")
            
            print(f"{'='*60}\n")
            
            # Send the command
            if send_to_esp32(f"AUTO_DISPENSE:{confirmed_chit_value}"):
                # Update LCD
                lcd.display_lines(
                    "AUTO DISPENSE!",
                    f"Chit: P{confirmed_chit_value}",
                    "Dispensing coins",
                    "Please wait..."
                )
                # Move to DISPENSING state and start timer
                detection_state = "DISPENSING"
                dispensing_start_time = time.time()
            else:
                print(f"‚ö†Ô∏è  Failed to send AUTO_DISPENSE command")
                lcd.display_lines(
                    "ERROR!",
                    "Communication",
                    "failed",
                    ""
                )
                time.sleep(2)
                # Reset to WAITING on error
                detection_state = "WAITING"
                detection_buffer.clear()
                confirmed_chit_value = None
                confirmed_confidence = 0.0
                lcd.display_lines(
                    "Ready - Scanning",
                    "Waiting for chit...",
                    "",
                    ""
                )
    
    elif detection_state == "DISPENSING":
        # Wait for ESP32 to complete dispensing
        display_frame = frame.copy()
        display_frame = cv2.resize(display_frame, (320, 240))
        
        elapsed_time = time.time() - dispensing_start_time
        cv2.putText(display_frame, f'Dispensing: P{confirmed_chit_value}', (10, 30), 
                   cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 165, 255), 2)
        cv2.putText(display_frame, f'Time: {elapsed_time:.1f}s', (10, 60), 
                   cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 165, 255), 2)
        cv2.putText(display_frame, 'Please wait...', (10, 90), 
                   cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 165, 255), 2)
        
        if use_gui:
            cv2.imshow('Chit Detection - Real-time', display_frame)
            cv2.waitKey(1)
        
        # Check for messages from ESP32
        esp32_msg = read_from_esp32()
        if esp32_msg and "DISPENSING_COMPLETE" in esp32_msg:
            print(f"\n{'='*60}")
            print(f"‚úÖ DISPENSING COMPLETE (Total time: {elapsed_time:.1f}s)")
            print(f"{'='*60}\n")
            
            lcd.display_lines(
                "COMPLETE!",
                f"P{confirmed_chit_value} dispensed",
                "Thank you!",
                ""
            )
            time.sleep(2)
            
            print("Waiting for next chit...\n")
            
            # Reset LCD to waiting state
            lcd.display_lines(
                "Ready - Scanning",
                "Waiting for chit...",
                "",
                ""
            )
            
            # Reset state machine
            detection_state = "WAITING"
            detection_buffer.clear()
            confirmed_chit_value = None
            confirmed_confidence = 0.0
        
        # Check for timeout
        elif elapsed_time > dispensing_timeout:
            print(f"\n{'='*60}")
            print(f"‚ö†Ô∏è  DISPENSING TIMEOUT after {elapsed_time:.1f}s")
            print(f"{'='*60}\n")
            
            lcd.display_lines(
                "TIMEOUT!",
                "Check ESP32",
                "and hoppers",
                ""
            )
            time.sleep(3)
            
            # Reset to WAITING on timeout
            detection_state = "WAITING"
            detection_buffer.clear()
            confirmed_chit_value = None
            confirmed_confidence = 0.0
            lcd.display_lines(
                "Ready - Scanning",
                "Waiting for chit...",
                "",
                ""
            )
    
    last_ir_state = ir_detected
